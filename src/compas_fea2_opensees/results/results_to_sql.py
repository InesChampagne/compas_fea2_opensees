"""
This script reads results from .out files generated by a finite element analysis and converts them into an SQLite database.
It supports various types of field outputs such as displacements, reaction forces, reaction moments, stresses, and section forces.
The script creates tables in the SQLite database to store these results and their descriptions.
"""
import os

def read_results_file(connection, field_output):
    """
    Read the .out results file and convert it to a dictionary.

    Parameters
    ----------
    database_path : path
        Path to the folder where the sqlite database will be created
    database_name : str
        Name of the database
    field_output : :class:`compas_fea2.problem.FieldOutput`
        FieldOutput object containing the nodes and/or element outputs to extract.
    """
    
    model = field_output.model
    step = field_output.step
    field_name = field_output.field_name
    database_path = field_output.problem.database_path

    results = []
    with open(os.path.join(database_path, f'{field_name}.out'), 'r') as f:
        lines = f.readlines()
        for line in lines:
            columns = line.split()
            
            key = int(columns[0])  # Convert the first column to int
            member = getattr(model, field_output._results_func)(key)[0]
            
            #FIXME: this does not take into account the integration points
            # which can be different from element implementation to element implementation
            values = list(map(float, columns[1:]))
            if len(values) < len(field_output.components_names):
                values = values + [0.]*(len(field_output.components_names) - len(values))
            elif len(values) > len(field_output.components_names):
                values = values[:len(field_output.components_names)]
            else:
                values = values
            
            results.append([member.key] + [step.name, member.part.name] + values)
    
    field_output.create_table_for_output_class(connection, results)
    





def process_modal_shapes(database_path, database_name):
    pass

    # field_info = {
    #     # Define the structure and components of different field outputs
    #     "u": {"num_of_comp": 3,
    #           "description_table": [['Spatial displacement', 'U1 U2 U3'], ['magnitude']],
    #           "field_table": ['U1', 'U2', 'U3', 'magnitude']},
    #     "rf": {"num_of_comp": 3,
    #           "description_table": [['Reaction forces', 'RF1 RF2 RF3'], ['magnitude']],
    #           "field_table": ['RF1', 'RF2', 'RF3', 'magnitude']},
    #     "rm": {"num_of_comp": 3,
    #           "description_table": [['Reaction moments', 'M1 M2 M3'], ['magnitude']],
    #           "field_table": ['RM1', 'RM2', 'RM3', 'magnitude']},
    #     "s2d": {"num_of_comp": 6,
    #           "description_table": [['Stresses', 'S11 S22 S12 M11 M22 M12'], [None]],
    #           "field_table": ['S11', 'S22', 'S12', 'M11', 'M22', 'M12', 'None']},
    #     "s3d": {"num_of_comp": 6,
    #           "description_table": [['Stresses', 'S11 S22 S33 S12 S23 S13'], [None]],
    #           "field_table": ['S11', 'S22', 'S33', 'S12', 'S23', 'S13', 'None']},
    #     "sf": {"num_of_comp": 6,
    #           "description_table": [['Section Forces', 'F11 F22 F33 M11 M22 M33'], [None]],
    #           "field_table": ['F11', 'F22', 'F33', 'M11', 'M22', 'M33', 'None']},
    # }

    # # Check if there are any node or element outputs
    # if not field_output.node_outputs and not field_output.element_outputs:
    #     print('WARNING - No field outputs found! Did you add an output request before running the analysis?')

    # if not field_output.node_outputs:
    #     field_output._node_outputs = []
    # if not field_output.element_outputs:
    #     field_output._element_outputs = []

    # # Process each field output
    # for field in field_output.node_outputs + field_output.element_outputs:
    #     field = field.lower()
    #     if field not in field_info:
    #         print(f'WARNING - the output request {field.upper()} is either not implemented or not available.')
    #         continue
    #     number_of_components = field_info[field]["num_of_comp"]
    #     results.setdefault(field, {})

    #     if field.upper() in field_output.node_outputs: 
    #         output_set = field_output.nodes_set or field_output.model.nodes
    #     else:
    #         output_set = field_output.elements_set or field_output.model.elements

    #     filepath = os.path.join(database_path, '{}.out'.format(field.lower()))
    #     if not os.path.exists(filepath):
    #         print(f"file {filepath} not found. Results not extracted.")
    #         continue
    #     with open(filepath, 'r') as f:
    #         lines = f.readlines()
    #         if not lines:
    #             if compas_fea2.VERBOSE:
    #                 print(f"WARNING: Empty file {filepath}. Results not extracted.")
    #             continue
    #         # take the last analysis step and ignore the time stamp (first value)
    #         data = [float(i) for i in lines[-1].split(' ')[1:]]

    #     results[field] = []
    #     for c, value in enumerate(output_set):
    #         step = field_output.step

    #         if field in field_output.node_outputs:
    #             object_properties = [step.name, value.part.name, 'node', 'nodal', value.key]
    #         else:
    #             object_properties = [step.name, value.part.name, 'element', 'nodal', value.key]

    #         components_results = data[c * number_of_components: c * number_of_components + number_of_components]
    #         if not components_results:
    #             if compas_fea2.VERBOSE:
    #                 print(f"WARNING: Empty entry in {field} field. Results Skipped!")
    #             continue

    #         invariants = []
    #         if not field_info[field]['description_table'][1][0]:
    #             invariants = [0]
    #         elif 'magnitude' in field_info[field]['description_table'][1]:
    #             u, v, w = components_results
    #             magnitude = sqrt(u ** 2 + v ** 2 + w ** 2)
    #             invariants.append(magnitude)
    #         else:
    #             raise ValueError('Invariant not supported')

    #         results[field].append(object_properties + components_results + invariants)

    #     if compas_fea2.VERBOSE:
    #         print('***** {0}.out data loaded *****'.format(filepath))







    # # Create the SQLite database and insert the results
    # database = os.path.join(database_path, f'{database_name}-results.db')

    # if os.path.exists(database):
    #     os.remove(database)

    # with create_connection_sqlite3(database) as conn:
    #     create_field_description_table_sqlite3(conn)
    #     for field_name, field_data in results.items():
    #         insert_field_description_sqlite3(
    #             conn,
    #             field_name.upper(),
    #             *field_info[field_name]['description_table'][0],
    #             *field_info[field_name]['description_table'][1]
    #         )
    #         create_field_table_sqlite3(
    #             conn,
    #             field_name.upper(),
    #             field_info[field_name]['field_table']
    #         )
    #         for result_data in field_data:
    #             insert_field_results_sqlite3(conn, field_name.upper(), result_data)
    #     conn.commit()


# def process_modal_shapes(database_path, database_name):
#     """Process modal shapes from the .out file and save them in the SQLite database."""
#     input_file = os.path.join(database_path, "modal_shapes_all_nodes.out")
#     if not os.path.exists(input_file):
#         print(f"Modal shapes file {input_file} not found!")
#         return

#     output_db = os.path.join(database_path, f'{database_name}-results.db')
#     print(f"Writing modal shapes to database: {output_db}")

#     conn = sqlite3.connect(output_db)
#     cursor = conn.cursor()

#     # Create table for eigenvalues
#     cursor.execute("""
#     CREATE TABLE IF NOT EXISTS eigenvalues (
#         mode INTEGER PRIMARY KEY,
#         eigenvalue REAL
#     )
#     """)

#     # Create table for modal shapes
#     cursor.execute("""
#     CREATE TABLE IF NOT EXISTS modal_shapes (
#         mode INTEGER,
#         node INTEGER,
#         dof_1 REAL,
#         dof_2 REAL,
#         dof_3 REAL,
#         dof_4 REAL,
#         dof_5 REAL,
#         dof_6 REAL,
#         PRIMARY KEY (mode, node)
#     )
#     """)
#     conn.commit()

#     # Parse the input file
#     current_mode = None
#     eigenvalues = []
#     with open(input_file, "r") as file:
#         for line in file:
#             line = line.strip()

#             # Parse eigenvalues
#             if line.startswith("Eigenvalues:"):
#                 eigenvalues = [float(val) for val in line.split(":")[1].split()]

#             # Detect a new mode
#             elif line.startswith("Mode"):
#                 current_mode = int(line.split()[1].strip(":"))

#             # Parse node data for the current mode
#             elif line.startswith("Node") and current_mode is not None:
#                 parts = line.split(":")
#                 node_id = int(parts[0].split()[1])
#                 dofs = [float(val) for val in parts[1].split()]

#                 # Insert modal shape data into the database
#                 cursor.execute("""
#                 INSERT INTO modal_shapes (mode, node, dof_1, dof_2, dof_3, dof_4, dof_5, dof_6)
#                 VALUES (?, ?, ?, ?, ?, ?, ?, ?)
#                 """, [current_mode, node_id] + dofs)

#     # Insert eigenvalues into the database
#     for mode, eigenvalue in enumerate(eigenvalues, start=1):
#         cursor.execute("""
#         INSERT INTO eigenvalues (mode, eigenvalue)
#         VALUES (?, ?)
#         """, [mode, eigenvalue])

#     conn.commit()
#     conn.close()

#     print(f"Modal shapes and eigenvalues successfully saved to {output_db}")